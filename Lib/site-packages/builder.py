#! /usr/bin/env python3
#
# Interpreter version: brython
#
from collections import OrderedDict

from browser import document as doc

from components import ArgInput
from components import Argument
from components import bind_links


# Functions & objects =========================================================
def hide_help_frame(ev):
    """
    Remove help popup from the HTML.
    """
    doc["help_placeholder"].innerHTML = ""
    doc["black_overlay"].style.display = "none"


def parse_arguments(ev):
    """
    Parse arguments from inputs and save the result to the output textarea.
    """
    text = a.__str__()

    if doc["output_use_spaces"].checked:
        text = text.replace("\t", "    ")

    doc["output"].value = text


# Object definitions ==========================================================
class ArgParser:
    """
    This object holds references to all argument tables and global argparse
    settings.

    Attr:
        arguments (ordered dict): References to :class:`Argument` objects.
        element (obj): Reference to `argument_parser` <span>.
        inputs (ordered dict): Reference to global settings inputs.
    """
    def __init__(self):
        self.arguments = OrderedDict()
        self.add_argument_callback()

        # parse all inputs belonging to the argparser objects
        self.element = doc["argument_parser"]
        arguments = self.element.get(selector="input") or []
        arguments.extend(self.element.get(selector="textarea") or [])

        self.inputs = OrderedDict(
            (x.id.split("_")[-1], ArgInput(element=x, parent=self))
            for x in arguments if x
        )

    def new_argument(self):
        """
        Create new :class:`Argument` object and bind events to the buttons.

        Returns:
            Argument object: Created object.
        """
        arg = Argument()
        self.bind_argument(arg)
        return arg

    def bind_argument(self, argument):
        """
        Bind buttons in `argument` object to callbacks methods in this object.
        """
        doc[argument.ID + "_argument_button_add"].bind(
            "click",
            self.add_argument_callback
        )
        doc[argument.ID + "_argument_button_rm"].bind(
            "click",
            self.remove_argument_callback
        )
        doc[argument.ID + "_argument_button_up"].bind(
            "click",
            self.move_arg_up_callback
        )
        doc[argument.ID + "_argument_button_down"].bind(
            "click",
            self.move_arg_down_callback
        )

    def add_argument_callback(self, ev=None):
        """
        Add new argument into HTML representation and internal dict.

        Note:
            This method is called asynchronously, when the button is pressed.
        """
        arg = self.new_argument()
        self.arguments[arg.ID] = arg

    def remove_argument_callback(self, ev=None):
        """
        Remove argument from HTML representation and internal dict.

        ID of the argument is parsed from `ev` parameter.

        Note:
            This method is called asynchronously, when the button is pressed.
        """
        if len(self.arguments) > 1:
            ID = ev.target.id.split("_")[0]
            self.arguments[ID].remove()
            del self.arguments[ID]

    def move_arg_up_callback(self, ev):
        """
        Switch two arguments - move the argument where the button was pressed
        down.

        Note:
            This method is called asynchronously, when the button is pressed.
        """
        ID = ev.target.id.split("_")[0]
        keys = list(self.arguments.keys())
        ioa = keys.index(ID)

        if len(self.arguments) > 1 and ioa > 0:
            arg1 = self.arguments[keys[ioa]]
            arg2 = self.arguments[keys[ioa - 1]]

            arg1.switch(arg2)

    def move_arg_down_callback(self, ev=None):
        """
        Switch two arguments - move the argument where the button was pressed
        down.

        Note:
            This method is called asynchronously, when the button is pressed.
        """
        ID = ev.target.id.split("_")[0]
        keys = list(self.arguments.keys())
        ioa = keys.index(ID)

        if len(self.arguments) > 1 and ioa < len(self.arguments) - 1:
            arg1 = self.arguments[keys[ioa]]
            arg2 = self.arguments[keys[ioa + 1]]

            arg1.switch(arg2)

    def __str__(self):
        # read value of all inputs in this object, pick only inputs with value
        vals = [
            str(x)
            for x in self.inputs.values()
            if x.wrapped_value is not None
        ]

        # add \n\t only if there are used inputs
        inp_string = ",\n\t".join(vals)
        if inp_string:
            inp_string = "\n\t" + inp_string + "\n"

        # put inputs to template
        ARG_PARSER_TEMPLATE = """import argparse

# ...
parser = argparse.ArgumentParser($parameters)
$arguments
args = parser.parse_args()

"""
        out = ARG_PARSER_TEMPLATE.replace("$parameters", inp_string)

        # convert arguments to strings
        arguments = ""
        for item in self.arguments.values():
            arguments += item.__str__()

        # put arguments to template
        return out.replace("$arguments", arguments)


# Main program ================================================================
if __name__ == '__main__':
    a = ArgParser()

    # bind click on output textarea with generation of the source code
    doc["output"].bind("click", parse_arguments)
    doc["output_use_spaces"].bind("click", parse_arguments)

    # bind links with popup help
    doc["black_overlay"].bind("click", hide_help_frame)
    bind_links(doc["argument_parser"])

    doc["loading_gears_background"].style.display = "none"