#! /usr/bin/env python3
#
# Interpreter version: brython
#
from browser import document as doc


def type_on_change_event(self, ev):
    """
    This code switches select for input when user selects `Custom` in
    `type` select element.
    """
    if ev.target.value == "custom":
        ID = self.element.id
        new_html = '<input id="%s" type="text" _non_str="true" ' % ID
        new_html += '_non_key="" _default="" />'
        ev.target.outerHTML = new_html

        self.element = doc[ID]


def action_on_change_event(self, ev):
    """
    Event raised when user changes value in `action` input.
    """
    bool_switches = [
        "count",
        "store_true",
        "store_false",
        "help",
        "version"
    ]
    bool_disables = [
        "type",
        "const",
        "nargs",
        "choices",
        "default",
        "metavar"
    ]

    # enable/disable other inputs
    disabled = (ev.target.value in bool_switches)
    disabled_inputs = [self.parent.inputs[x] for x in bool_disables]

    for item in disabled_inputs:
        item.disabled = disabled


class ArgInput:
    """
    This class is used to wrap <input>, <select> and <textarea> HTML elements.

    It provides unified setters and getters for those elements, allows to
    define callbacks when clicked/changed, switch two :class:`ArgInput`
    objects, serialize them to string, enable/disable them and so on.

    Attr:
        ID (str): Unique ID. Thanks to this, objects know which HTML elements
                  belong to them.
        name (str): Name of the argparse argument - `descr`, `type` and so on.
        color (str): Default color for input text.
        parent (str): Pointer to :class:`Argument`, where this object is
                      stored. This can be used to disable other inputs and so
                      on.
        element (obj): Pointer to HTML element.
        is_text_type (bool): True for inputs/textareas, false for select,
                             checkboxes and others.
        wrapped_value (str): Value used when element is serialized to python.
        value (str): Clean value of the element.
        disabled (bool): Property which allows to enable/disable HTML element.
    """
    def __init__(self, element, parent):
        self.ID = element.id.split("_")[0]
        self.name = element.id.split("_")[-1]
        self.color = "gray"

        self.parent = parent
        self.element = element  # reference to html object

        if self.element.value == "":
            self.element.value = self.element.title
            self.element.style.color = self.color

        if self.is_text_type:
            element.bind("focus", self.input_remove_help_callback)
            element.bind("blur", self.input_add_help_callback)
        elif element.nodeName == "SELECT":
            element.bind("change", self.on_change_callback)

        self.on_change_events = {
            "type": type_on_change_event,
            "action": action_on_change_event
        }

    def on_change_callback(self, ev):
        """
        Callback called every time the select HTML element is changed.
        """
        func = self.on_change_events.get(self.name, None)

        if func:
            func(self, ev)

    def input_remove_help_callback(self, ev):
        """
        Called when user clicks to the input/textarea element to remove help.
        """
        if ev.target.value == ev.target.title:
            ev.target.value = ""
            ev.target.style.color = "black"

    def input_add_help_callback(self, ev):
        """
        Called every time user removes focus from input element to restere
        help, if the input is blank.
        """
        if ev.target.value == "":
            ev.target.value = ev.target.title
            ev.target.style.color = self.color

    @property
    def wrapped_value(self):
        """
        Property to wrap the internal raw value to string.

        This is used for string serialization - some of the elements needs to
        add quotes, some have default values and so on.
        """
        if self.disabled:
            return None

        # selects
        if not self.is_text_type and \
           self.element.value == self.element._default:
            return None

        # checkboxes
        if self.element.type == "checkbox":
            value = self.element.checked

            if self.element._default == str(value):
                return None

            return value

        # text elements - textearea/input
        if self.element.value != self.element.title:
            # nargs are strings only in some special cases (+*?)
            if self.name == "nargs" and self.element.value in "+*?":
                return '"%s"' % self.element.value

            if self.element._non_str.strip():
                return self.element.value

            return self._wrap_strings()

        return None

    def _wrap_strings(self):
        def wrap(text, first_wrap, other_wraps, other_indents, line_len=79):
            """
            Wrap `text` after `first_wrap` chars and then every `other_wraps`
            characters.

            Args:
                text (str): Text which will be wrapped.
                first_wrap (int): Perform first wrap after `first_wrap`
                    characters.
                other_wraps (int): Wrap other lines after `other_wraps`
                    characters.

            Returns:
                list: List of strings wrapped after `first_wrap` and \
                      `other_wraps`.
            """
            out = []

            if len(text) <= line_len:
                return text

            # first wrap
            out.append(text[:first_wrap])
            text = text[first_wrap:]

            # other wraps
            while len(text) > other_wraps:
                out.append(other_indents + text[:other_wraps])
                text = text[other_wraps:]

            return "\\\n".join(out + [other_indents + text])

        val = self.element.value.replace(r"\\", r"\\")  # don't even ask

        # use """ for multiline strings
        quote = '"'
        argument_len = len((4 * " ") + self.name + "=" + quote + val + quote)
        MAX_LINELEN = 79
        if "\n" in val or argument_len >= MAX_LINELEN:
            quote = quote * 3

        # escape quotes in string
        if quote in val:
            val = val.replace(quote, quote.replace('"', '\\"'))

        # can fit to one line?
        first_indentation = "    %s=%s" % (self.name, quote)
        if len(first_indentation + val + quote) <= MAX_LINELEN:
            return quote + val + quote

        # wrap long lines
        val = wrap(
            text=quote + val,
            first_wrap=MAX_LINELEN - len(first_indentation),
            other_wraps=MAX_LINELEN - len(first_indentation),
            other_indents=len(first_indentation) * " ",
            line_len=MAX_LINELEN,
        )
        return val + quote

    @property
    def value(self):
        """
        Property to access value of the HTML element.
        """
        if self.element.type == "checkbox":
            return self.element.checked

        return self.element.value

    @value.setter
    def value(self, new_val):
        """
        Property to set value of the HTML element.
        """
        if self.element.type == "checkbox":
            self.element.checked = new_val
        else:
            self.element.value = new_val

    @property
    def is_text_type(self):
        """
        Getter showing whether the ArgInput object wraps text element or
        switch/checkbox.
        """
        return (self.element.type == "text" or
                self.element.nodeName == "TEXTAREA")

    @property
    def disabled(self):
        """
        Abstration over disabled property.
        """
        return self.element.disabled

    @disabled.setter
    def disabled(self, val):
        """
        Setteer for diabled property.
        """
        self.element.disabled = val

    def switch(self, inp2):
        """
        Switch two ArgInput objects.

        Switch values, if the objects are of the same type, or whole HTML
        elements, if they are different types.

        Args:
            inp2 (object): :class:`ArgInput` class.
        """
        inp1 = self

        el1, el2 = inp1.element, inp2.element
        el1.style.color, el2.style.color = el2.style.color, el1.style.color

        if inp1.element.nodeName != inp2.element.nodeName:
            val1, val2 = inp1.value, inp2.value
            el1.id, el2.id = el2.id, el2.id
            el1.outerHTML, el2.outerHTML = el2.outerHTML, el2.outerHTML

            inp1.element = doc[inp1.ID + "_argument_" + inp1.name]
            inp2.element = doc[inp2.ID + "_argument_" + inp2.name]
            inp1.value, inp2.value = val2, val1
        else:
            inp1.value, inp2.value = inp2.value, inp1.value

    def __str__(self):
        if self.element._non_key:
            return str(self.wrapped_value)

        return self.name + "=" + str(self.wrapped_value)

    def __hash__(self):
        return hash(self.ID)
