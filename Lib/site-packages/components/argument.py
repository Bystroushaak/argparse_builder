#! /usr/bin/env python3
#
# Interpreter version: brython
#
from collections import OrderedDict

from browser import html
from browser import document as doc

from .arginput import ArgInput


# Variables ===================================================================
_ARG_COUNTER = range(100000).__iter__()  # argument table ID pool
ARG_TEMPLATE = """parser.add_argument(
\t$parameters
)
"""


def get_id_from_pool():
    """
    Returns:
        int: Incremented ID from previous call.
    """
    return _ARG_COUNTER.__next__()


def show_help_frame(ev):
    """
    Add help popup to the HTML.
    """
    src = '<iframe id="white_content" src="' + ev.target.fhref + '"></iframe>'

    doc["help_placeholder"].innerHTML = src
    doc["black_overlay"].style.display = "inline"
    doc["white_content"].style.display = "inline"


def bind_links(container):
    """
    Bind all links in given `container` to popup help/iframe.

    Note:
        This function can be called only once for each link, or it wouln't
        work.
    """
    # bind all links to show popup with help
    for el in container.get(selector="a"):
        el.fhref = el.href
        el.href = "#"
        el.bind("click", show_help_frame)


class Argument:
    """
    This object is used to represent sets of :class:`ArgInput` objects, in
    order as they are defined in <span> with ID `arguments`.

    It can also :func:`remove` itself from the HTML page and serialize content
    of the inputs to python code.

    Attr:
        ID (str): Unique ID. Thanks to this, objects know which HTML elements
                  belong to them.
        element (obj): Pointer to corresponding HTML table with inputs.
        inputs (ordered dict): Dictionary with HTML inputs stored in format
               ``{"$NAME": el_reference}`` where ``$NAME`` is last part of
               HTML `id` splitted by ``_``.
    """
    def __init__(self):
        self.ID = str(get_id_from_pool())
        self.element = self._add_html_repr()

        arguments = self.element.get(selector="input")
        arguments = [x for x in arguments if x.type != "button"]
        arguments.extend(self.element.get(selector="select"))
        arguments.extend(self.element.get(selector="textarea"))

        self.inputs = OrderedDict(
            (x.id.split("_")[-1], ArgInput(element=x, parent=self))
            for x in arguments if x
        )

        bind_links(self.element)

    def _add_html_repr(self):
        """
        Add HTML representation of the argument to the HTML page.
        """
        template = doc["argument_template"].innerHTML

        table = html.TABLE(id=self.ID + "_argument", Class="argument_table")
        table.html = template.replace("$ID", self.ID)
        doc["arguments"] <= table

        return table

    def remove(self):
        """
        Remove argument from HTML.
        """
        doc[self.ID + "_argument"].outerHTML = ""

    def switch(self, arg2):
        """
        Switch all values in this Argument with `arg2`.
        """
        assert isinstance(arg2, Argument)

        for key in self.inputs.keys():
            self.inputs[key].switch(arg2.inputs[key])

    def __str__(self):
        # collect strings from all inputs
        vals = [
            str(x)
            for x in self.inputs.values()
            if x.wrapped_value is not None
        ]

        if not vals:
            return ""

        return ARG_TEMPLATE.replace(
            "$parameters",
            ",\n\t".join(vals)
        )
